// Author: Simon.Gockner
// Created: 2025-09-01
// Copyright(c) 2025 SimonG. All Rights Reserved.

using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SignalR.StrongTypedConnections.Generators;

[Generator]
public class StrongTypedHubConnectionGenerator : IIncrementalGenerator
{
    private const string EXTENSION_CLASS_NAME = "StrongTypedHubConnectionExtensions";
    private const string BUILDER_CLASS_NAME = "StrongTypedHubConnectionBuilder";
    private const string STRONG_HUB_EXTENSION_CLASS_NAME = "StrongTypedHubExtensions";
    
    private const string GENERATED_FILE_HEADER = "//---GENERATED by StrongTypedHubConnectionGenerator! DO NOT EDIT!---";
    private const string INDENT = "    ";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        string? classNamespace = typeof(StrongTypedHubConnectionGenerator).Namespace;
        context.RegisterPostInitializationOutput(c => c.AddSource($"{EXTENSION_CLASS_NAME}.g.cs", GenerateConnectionExtensionClass(classNamespace, EXTENSION_CLASS_NAME)));
        
        IncrementalValuesProvider<ITypeSymbol?> syntaxProvider = context.SyntaxProvider.CreateSyntaxProvider(IsCallToGenerateStrongHub, GetTypeArgument);
        
        context.RegisterSourceOutput(syntaxProvider.Collect(), GenerateTypeDependentClasses);
        context.RegisterSourceOutput(syntaxProvider, GenerateStrongHubConnection);
    }

    private string GenerateConnectionExtensionClass(string? classNamespace, string className)
    {
        StringBuilder stringBuilder = new();
        
        stringBuilder.AppendLine(GENERATED_FILE_HEADER);
        stringBuilder.AppendLine();
        
        stringBuilder.AppendLine("using Microsoft.AspNetCore.SignalR.Client;");
        stringBuilder.AppendLine();
        
        if (classNamespace is not null)
        {
            stringBuilder.AppendLine($"namespace {classNamespace};");
            stringBuilder.AppendLine();
        }
        
        stringBuilder.AppendLine($"public static class {className}");
        stringBuilder.AppendLine("{");
        
        stringBuilder.AppendLine($"{INDENT}public static T ToStrongTypedHub<T>(this HubConnection hubConnection) where T : IStrongHub");
        stringBuilder.AppendLine($"{INDENT}{{");
        stringBuilder.AppendLine($"{INDENT}{INDENT}return hubConnection.BuildStrongTypedHub<T>();");
        stringBuilder.AppendLine($"{INDENT}}}");
        stringBuilder.AppendLine();
        
        stringBuilder.AppendLine($"{INDENT}private static T BuildStrongTypedHub<T>(this HubConnection hubConnection) where T : IStrongHub");
        stringBuilder.AppendLine($"{INDENT}{{");
        stringBuilder.AppendLine($"{INDENT}{INDENT}return Builder.Create<T>(hubConnection);");
        stringBuilder.AppendLine($"{INDENT}}}");
        
        stringBuilder.AppendLine("}");
        
        return stringBuilder.ToString();
    }

    private bool IsCallToGenerateStrongHub(SyntaxNode node, CancellationToken cancellationToken)
    {
        if (!node.IsKind(SyntaxKind.GenericName) || node is not GenericNameSyntax genericNameSyntax)
            return false;

        if (!genericNameSyntax.ToString().StartsWith("ToStrongTypedHub"))
            return false;

        if (genericNameSyntax.TypeArgumentList.Arguments[0] is not IdentifierNameSyntax)
            return false;

        return true;
    }
    
    private ITypeSymbol? GetTypeArgument(GeneratorSyntaxContext syntaxContext, CancellationToken cancellationToken)
    {
        if (syntaxContext.Node is not GenericNameSyntax genericNameSyntax)
            return null;
        
        if (genericNameSyntax.TypeArgumentList.Arguments[0] is not IdentifierNameSyntax identifierNameSyntax)
            return null;

        if (syntaxContext.SemanticModel.GetSymbolInfo(identifierNameSyntax).Symbol is not ITypeSymbol typeSymbol)
            return null;

        return typeSymbol;
    }
    
    private void GenerateTypeDependentClasses(SourceProductionContext context, ImmutableArray<ITypeSymbol?> types)
    {
        string? classNamespace = typeof(StrongTypedHubConnectionGenerator).Namespace;
        context.AddSource($"{BUILDER_CLASS_NAME}.g.cs", GenerateBuilderClassSourceCode(classNamespace, types));
        context.AddSource($"{STRONG_HUB_EXTENSION_CLASS_NAME}.g.cs", GenerateHubExtensionClassSourceCode(classNamespace, types));
    }
    
    private void GenerateStrongHubConnection(SourceProductionContext context, ITypeSymbol? typeSymbol)
    {
        if (typeSymbol is null)
            return;
        
        context.AddSource($"Generated{typeSymbol.Name}.g.cs", GenerateStrongHubConnectionSourceCode(typeSymbol));
    }
    
    private string GenerateBuilderClassSourceCode(string? classNamespace, ImmutableArray<ITypeSymbol?> types)
    {
        StringBuilder stringBuilder = new();

        stringBuilder.AppendLine(GENERATED_FILE_HEADER);
        stringBuilder.AppendLine();

        stringBuilder.AppendLine("using Microsoft.AspNetCore.SignalR.Client;");

        foreach (string typeNamespace in GetNamespacesOfTypes(types)) 
            stringBuilder.AppendLine($"using {typeNamespace};");
        
        stringBuilder.AppendLine();

        if (classNamespace is not null)
        {
            stringBuilder.AppendLine($"namespace {classNamespace};");
            stringBuilder.AppendLine();
        }
        
        stringBuilder.AppendLine("public static class Builder");
        stringBuilder.AppendLine("{");
        stringBuilder.AppendLine($"{INDENT}public static T Create<T>(HubConnection hubConnection) where T : IStrongHub");
        stringBuilder.AppendLine($"{INDENT}{{");

        foreach (ITypeSymbol? type in types)
        {
            if (type is null)
                continue;
            
            stringBuilder.AppendLine($"{INDENT}{INDENT}if (typeof(T) == typeof({type.Name}))");
            stringBuilder.AppendLine($"{INDENT}{INDENT}{{");
            stringBuilder.AppendLine($"{INDENT}{INDENT}{INDENT}return (T) (object) new Generated{type.Name}(hubConnection);");
            stringBuilder.AppendLine($"{INDENT}{INDENT}}}");
            stringBuilder.AppendLine();
        }
        
        stringBuilder.AppendLine($"{INDENT}{INDENT}throw new Exception(\"Invalid type.\");");
        
        stringBuilder.AppendLine($"{INDENT}}}");
        stringBuilder.AppendLine("}");

        return stringBuilder.ToString();
    }

    private string GenerateHubExtensionClassSourceCode(string? classNamespace, ImmutableArray<ITypeSymbol?> types)
    {
        StringBuilder stringBuilder = new();
        
        stringBuilder.AppendLine(GENERATED_FILE_HEADER);
        stringBuilder.AppendLine();
        
        stringBuilder.AppendLine("using Microsoft.AspNetCore.SignalR.Client;");
        stringBuilder.AppendLine("using System.Linq.Expressions;");
        
        foreach (string typeNamespace in GetNamespacesOfTypes(types)) 
            stringBuilder.AppendLine($"using {typeNamespace};");
        
        stringBuilder.AppendLine();
        
        if (classNamespace is not null)
        {
            stringBuilder.AppendLine($"namespace {classNamespace};");
            stringBuilder.AppendLine();
        }
        
        stringBuilder.AppendLine($"public static class {STRONG_HUB_EXTENSION_CLASS_NAME}");
        stringBuilder.AppendLine("{");
        
        foreach (ITypeSymbol? type in types)
        {
            if (type is null)
                continue;

            stringBuilder.AppendLine($"{INDENT}public static Task StartAsync(this {type.Name} hub)");
            stringBuilder.AppendLine($"{INDENT}{{");
            stringBuilder.AppendLine($"{INDENT}{INDENT}if (hub is not Generated{type.Name} generatedHub)");
            stringBuilder.AppendLine($"{INDENT}{INDENT}{INDENT}throw new Exception(\"Invalid hub.\");");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine($"{INDENT}{INDENT}return generatedHub.HubConnection.StartAsync();");
            stringBuilder.AppendLine($"{INDENT}}}");
            stringBuilder.AppendLine();
            
            stringBuilder.AppendLine($"{INDENT}public static Task StopAsync(this {type.Name} hub)");
            stringBuilder.AppendLine($"{INDENT}{{");
            stringBuilder.AppendLine($"{INDENT}{INDENT}if (hub is not Generated{type.Name} generatedHub)");
            stringBuilder.AppendLine($"{INDENT}{INDENT}{INDENT}throw new Exception(\"Invalid hub.\");");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine($"{INDENT}{INDENT}return generatedHub.HubConnection.StopAsync();");
            stringBuilder.AppendLine($"{INDENT}}}");
            stringBuilder.AppendLine();
            
            stringBuilder.AppendLine($"{INDENT}public static ValueTask DisposeAsync(this {type.Name} hub)");
            stringBuilder.AppendLine($"{INDENT}{{");
            stringBuilder.AppendLine($"{INDENT}{INDENT}if (hub is not Generated{type.Name} generatedHub)");
            stringBuilder.AppendLine($"{INDENT}{INDENT}{INDENT}throw new Exception(\"Invalid hub.\");");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine($"{INDENT}{INDENT}return generatedHub.HubConnection.DisposeAsync();");
            stringBuilder.AppendLine($"{INDENT}}}");
            
            INamedTypeSymbol? strongHubInterface = type.Interfaces.FirstOrDefault(i => i.Name == "IStrongHub" && i.IsGenericType);
            if (strongHubInterface is null)
                continue;
            
            string clientTypeName = strongHubInterface.TypeArguments[0].Name;

            for (int i = 1; i <= 5; i++)
            {
                stringBuilder.AppendLine();
                AppendOnMethod(type.Name, clientTypeName, i, stringBuilder);
            }
        }
        
        stringBuilder.AppendLine("}");
        
        return stringBuilder.ToString();
    }
    
    private IEnumerable<string> GetNamespacesOfTypes(ImmutableArray<ITypeSymbol?> types) =>
        types.OfType<ITypeSymbol>()
            .Select(s => s.ContainingNamespace.IsGlobalNamespace ? null : s.ContainingNamespace.ToString())
            .OfType<string>()
            .Distinct();

    private void AppendOnMethod(string hubTypeName, string clientTypeName, int numberOfParameters, StringBuilder stringBuilder)
    {
        string parameterList = string.Join(", ", Enumerable.Range(1, numberOfParameters).Select(i => $"T{i}"));
        
        stringBuilder.AppendLine($"{INDENT}public static IDisposable On<{parameterList}>(this {hubTypeName} hub, Expression<Func<{clientTypeName}, Delegate>> expression, Action<{parameterList}> handler)");
        stringBuilder.AppendLine($"{INDENT}{{");
        stringBuilder.AppendLine($"{INDENT}{INDENT}if (expression.Body is not UnaryExpression unaryExpression)");
        stringBuilder.AppendLine($"{INDENT}{INDENT}{INDENT}throw new ArgumentException(\"Invalid argument.\", nameof(expression));");
        stringBuilder.AppendLine();
        stringBuilder.AppendLine($"{INDENT}{INDENT}if (unaryExpression.Operand is not MethodCallExpression methodCallExpression)");
        stringBuilder.AppendLine($"{INDENT}{INDENT}{INDENT}throw new ArgumentException(\"Invalid argument.\", nameof(expression));");
        stringBuilder.AppendLine();
        stringBuilder.AppendLine($"{INDENT}{INDENT}if (hub is not Generated{hubTypeName} generatedHub)");
        stringBuilder.AppendLine($"{INDENT}{INDENT}{INDENT}throw new Exception(\"Invalid hub.\");");
        stringBuilder.AppendLine();
        stringBuilder.AppendLine($"{INDENT}{INDENT}string methodName = methodCallExpression.Method.Name;");
        stringBuilder.AppendLine($"{INDENT}{INDENT}return generatedHub.HubConnection.On<{parameterList}>(methodName, handler);");
        stringBuilder.AppendLine($"{INDENT}}}");
    }

    private string GenerateStrongHubConnectionSourceCode(ITypeSymbol typeSymbol)
    {
        string typeName = typeSymbol.Name;
        string? typeNamespace = typeSymbol.ContainingNamespace.IsGlobalNamespace ? null : typeSymbol.ContainingNamespace.ToString();
        
        StringBuilder stringBuilder = new();

        stringBuilder.AppendLine(GENERATED_FILE_HEADER);
        stringBuilder.AppendLine();

        stringBuilder.AppendLine("using Microsoft.AspNetCore.SignalR.Client;");
        stringBuilder.AppendLine();

        if (typeNamespace is not null)
        {
            stringBuilder.AppendLine($"namespace {typeNamespace};");
            stringBuilder.AppendLine();
        }

        stringBuilder.AppendLine($"public class Generated{typeName} : {typeName}, IAsyncDisposable");
        stringBuilder.AppendLine("{");
        
        stringBuilder.AppendLine($"{INDENT}public Generated{typeName}(HubConnection hubConnection)");
        stringBuilder.AppendLine($"{INDENT}{{");
        stringBuilder.AppendLine($"{INDENT}{INDENT}HubConnection = hubConnection;");
        stringBuilder.AppendLine($"{INDENT}}}");
        
        stringBuilder.AppendLine();
        stringBuilder.AppendLine($"{INDENT}public HubConnection HubConnection {{ get; }}");
        
        foreach (ISymbol? member in typeSymbol.GetMembers())
        {
            if (member is not IMethodSymbol methodSymbol)
                continue;
            
            stringBuilder.AppendLine();
            
            string modifier = methodSymbol.DeclaredAccessibility.ToString().ToLower();
            string parameterList = string.Join(", ", methodSymbol.Parameters.Select(p => $"{p.Type} {p.Name}"));
            
            stringBuilder.AppendLine($"{INDENT}{modifier} {methodSymbol.ReturnType.Name} {methodSymbol.Name}({parameterList})");
            stringBuilder.AppendLine($"{INDENT}{{");

            if (methodSymbol.Parameters.Length != 0)
            {
                string passedParameters = string.Join(", ", methodSymbol.Parameters.Select(p => p.Name));
                stringBuilder.AppendLine($"{INDENT}{INDENT}return HubConnection.InvokeAsync(\"{methodSymbol.Name}\", {passedParameters});");
            }
            else
                stringBuilder.AppendLine($"{INDENT}{INDENT}return HubConnection.InvokeAsync(\"{methodSymbol.Name}\");");


            stringBuilder.AppendLine($"{INDENT}}}");
        }
        
        stringBuilder.AppendLine();
        
        stringBuilder.AppendLine($"{INDENT}public async ValueTask DisposeAsync()");
        stringBuilder.AppendLine($"{INDENT}{{");
        stringBuilder.AppendLine($"{INDENT}{INDENT}await HubConnection.DisposeAsync();");
        stringBuilder.AppendLine($"{INDENT}}}");
        
        stringBuilder.AppendLine("}");
        
        return stringBuilder.ToString();
    }
}